# 3章: ストレージエンジンの概念

> **この章で理解できること:** クエリーエンジンが作った Statement を受け取って、実際にデータをファイルに保存・検索する仕組み。Pager・B+Tree・スキーマといった概念を、コードに入る前に図解で把握する。

> **この章の概念を理解済みなら → [4章: ストレージエンジンの実装詳細](./chapter4_storage_engine_impl.md) に進んでください**

---

## 3-1 なぜストレージエンジンが必要か

### メモリだけでは消える

プログラムが動いている間、データはメモリ上にあります。しかし、プログラムを終了するとメモリの内容は消えてしまいます。

```
┌─────────────┐     プログラム終了     ┌─────────────┐
│   メモリ     │     ───────────→     │   メモリ     │
│  users:      │                      │  (空)        │
│   Alice      │                      │              │
│   Bob        │                      │              │
└─────────────┘                      └─────────────┘
         データが消える！
```

データベースは「プログラムを終了しても次回起動時にデータが残っている」必要があります。そのために、データを **ファイルに書き出す（永続化）** 仕組みが必要です。

### Go版: JSON丸ごと保存

参考にした Go 版の SQLight では、テーブルの全データを **JSON ファイルにまるごと書き出す** 方式でした。

```json
{
  "users": {
    "columns": [...],
    "records": [
      { "id": 1, "name": "Alice" },
      { "id": 2, "name": "Bob" },
      ...
    ]
  }
}
```

この方式はシンプルですが、問題があります:

```
問題: レコード1件追加するだけでも、全データを書き直す

  [レコード1000件のテーブル] → INSERT 1件 → [1001件すべてを JSON に書き出し]

  テーブルが大きくなるほど遅くなる
```

### 本プロジェクト: ページベースバイナリ

本プロジェクトでは、SQLite と同じように **ページ** という固定サイズのブロック単位でデータを管理します。

```
JSON方式:                    ページ方式:
┌──────────────────┐        ┌──────┐┌──────┐┌──────┐┌──────┐
│ {                │        │Page 0││Page 1││Page 2││Page 3│
│   "users": {     │        │ヘッダー ││スキーマ││データ ││データ │
│     "records": [ │        └──────┘└──────┘└──────┘└──────┘
│       {...},     │
│       {...},     │        INSERT → Page 3 だけ書き換え
│       ...        │                (他のページはそのまま)
│     ]            │
│   }              │
│ }                │
└──────────────────┘
INSERT → 全部書き直し
```

**ページ方式の利点:**
- 変更があったページだけを書き換えればよい
- データ量が増えても、必要なページだけ読めばよい
- SQLite と同じ考え方で、RDB の基本を学べる

---

## 3-2 「ページ」とは何か — 固定サイズブロックの考え方

### ファイルをページに区切る

`.db` ファイルは、**4096バイト(4KB)ごとに区切られたページの並び** です。

```
sqlight.db ファイル
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  ┌──────────┐┌──────────┐┌──────────┐┌──────────┐      │
│  │  Page 0  ││  Page 1  ││  Page 2  ││  Page 3  │ ... │
│  │ (4096B)  ││ (4096B)  ││ (4096B)  ││ (4096B)  │      │
│  └──────────┘└──────────┘└──────────┘└──────────┘      │
│  ↑           ↑           ↑           ↑                  │
│  0バイト目    4096バイト目  8192バイト目  12288バイト目     │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**ページ番号とファイル位置の関係:**

```
ページ N のファイル上の開始位置 = N × 4096 バイト

ページ 0 → 0 バイト目から
ページ 1 → 4096 バイト目から
ページ 2 → 8192 バイト目から
ページ 3 → 12288 バイト目から
...
```

### 4種類のページ

各ページには「種類」があり、先頭1バイトで区別されます。

```
┌──────────────────────────────────────────────────────────┐
│ Page 0: ヘッダーページ                                     │
│   ファイル全体の情報を持つ（マジックナンバー、ページサイズ、    │
│   総ページ数、スキーマページの位置）                          │
│   → 本の「奥付」のようなもの                                │
├──────────────────────────────────────────────────────────┤
│ Page 1: スキーマページ                                     │
│   テーブルの定義情報を持つ（テーブル名、カラム名、型、         │
│   各テーブルのデータがどのページから始まるか）                  │
│   → 本の「目次」のようなもの                                │
├──────────────────────────────────────────────────────────┤
│ Page 2〜: データページ（リーフノード）                       │
│   実際のレコードが格納される                                 │
│   → 本の「本文ページ」のようなもの                           │
├──────────────────────────────────────────────────────────┤
│ Page N: データページ（内部ノード）                           │
│   B+Tree の道しるべ（どのリーフに目的のデータがあるか）       │
│   → 本の「索引」のようなもの                                │
└──────────────────────────────────────────────────────────┘
```

### 具体例: CREATE TABLE → INSERT を実行した時のページの様子

```
初期状態 (データベース作成直後):
┌──────────┐┌──────────┐
│  Page 0  ││  Page 1  │
│ ヘッダー   ││ スキーマ   │
│ 総ページ:2 ││ テーブル:0 │
└──────────┘└──────────┘

CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT); 実行後:
┌──────────┐┌──────────┐┌──────────┐
│  Page 0  ││  Page 1  ││  Page 2  │
│ ヘッダー   ││ スキーマ   ││ リーフ    │
│ 総ページ:3 ││ users:    ││ (空)     │
│          ││  root→P2  ││          │
└──────────┘└──────────┘└──────────┘

INSERT INTO users (id, name) VALUES (1, 'Alice'); 実行後:
┌──────────┐┌──────────┐┌──────────────┐
│  Page 0  ││  Page 1  ││    Page 2    │
│ ヘッダー   ││ スキーマ   ││   リーフ      │
│ 総ページ:3 ││ users:    ││ [1, "Alice"] │
│          ││  root→P2  ││              │
└──────────┘└──────────┘└──────────────┘

さらに INSERT して 2件に:
┌──────────┐┌──────────┐┌───────────────────────┐
│  Page 0  ││  Page 1  ││       Page 2          │
│ ヘッダー   ││ スキーマ   ││      リーフ            │
│ 総ページ:3 ││ users:    ││ [1, "Alice"]          │
│          ││  root→P2  ││ [2, "Bob"]            │
└──────────┘└──────────┘└───────────────────────┘
```

---

## 3-3 「Pager」とは何か — ページ管理人の役割

### Pager の抽象化

Pager は「ページ番号を指定すれば、ファイルの正しい位置を読み書きしてくれる」存在です。

```
上位レイヤー (B+Tree や Database)
  │
  │  「ページ2を読みたい」
  │  「ページ3に書き込みたい」
  │  「新しいページがほしい」
  │
  ▼
┌─────────────────────────────────────────┐
│              Pager                       │
│                                         │
│  readPage(2)                            │
│    → ファイルの 2×4096=8192 バイト目から   │
│      4096バイト読み込んで返す              │
│                                         │
│  writePage(3, data)                     │
│    → ファイルの 3×4096=12288 バイト目に   │
│      4096バイト書き込む                   │
│                                         │
│  allocatePage()                         │
│    → 新しいページ番号を発行して           │
│      空のページをファイルに追加            │
│                                         │
└──────────────────┬──────────────────────┘
                   │
                   ▼
          ┌─────────────────┐
          │  sqlight.db     │
          │  (バイナリファイル) │
          └─────────────────┘
```

**Pager の役割をまとめると:**

| 操作 | 意味 |
|---|---|
| `open(ファイルパス)` | ファイルを開く（なければ新規作成） |
| `readPage(ページ番号)` | 指定ページの内容を読み込む |
| `writePage(ページ番号, データ)` | 指定ページにデータを書き込む |
| `allocatePage()` | 新しい空ページを追加し、そのページ番号を返す |
| `close()` | ファイルを閉じる |

**ポイント:** B+Tree や Database は「ファイルの何バイト目」を一切意識しません。すべて「ページ番号」でやり取りします。この抽象化のおかげで、上位のコードがシンプルに保たれます。

---

## 3-4 「B+Tree」とは何か — データを効率的に探す仕組み

### なぜ B+Tree が必要か

レコードが少ないうちは、全レコードを順番に見ていけば目的のデータは見つかります。しかしレコードが増えると、全件走査は遅くなります。

```
1000件のレコードから id=500 を探す:

方法A: 全件走査 (リーフを順番に見る)
  → 最悪1000回の比較が必要

方法B: B+Tree で探す (道しるべを辿る)
  → 3〜4回の比較で見つかる
```

B+Tree は、データを **ソート済みのツリー構造** で管理することで、効率的な検索を実現します。

### B+Tree の構造 — 内部ノードとリーフノード

B+Tree は **2種類のノード** で構成されます。各ノードは1つのページに対応します。

```
                    ┌───────────────┐
                    │  内部ノード     │ ← 道しるべ (データは持たない)
                    │   [5]         │    「5未満は左、5以上は右」
                    └───┬───────┬───┘
                        │       │
               ┌────────┘       └────────┐
               ▼                         ▼
      ┌─────────────────┐      ┌─────────────────┐
      │  リーフノード     │ ──→ │  リーフノード     │ ← 実データが入っている
      │  [1] [2] [3] [4]│      │  [5] [6] [7] [8]│
      └─────────────────┘      └─────────────────┘
              ↑                         ↑
           Page 3                    Page 4
       リンクリストで繋がっている (→)
```

**内部ノード（道しるべ）:**
- 実際のデータは持たない
- 「このキーより小さいデータは左の子に、大きいデータは右の子に」という案内役
- 本の索引ページのようなもの

**リーフノード（実データ）:**
- 実際のレコードが格納されている
- キーの昇順でソートされている
- 隣のリーフノードへの **リンク**（右兄弟ポインタ）を持つ

### リーフのリンクリスト — 全件走査用

リーフノード同士は **リンクリスト** で繋がっています。`SELECT *` のように全件取得する時は、最も左のリーフから右へ順番に辿れば、ソート済みの全レコードが取得できます。

```
SELECT * FROM users; の実行:

  1. 最左のリーフを見つける (内部ノードを左へ降りる)
  2. リーフの全レコードを読む
  3. 右兄弟ポインタを辿って次のリーフへ
  4. 右兄弟がなくなるまで繰り返す

  ┌─────────┐    ┌─────────┐    ┌─────────┐
  │ [1] [2] │ →  │ [3] [4] │ →  │ [5] [6] │ → (終わり)
  └─────────┘    └─────────┘    └─────────┘
   全部読む        全部読む        全部読む

  結果: [1, 2, 3, 4, 5, 6] がソート済みで取得できる
```

### ノード分割 — データが増えるとページが分裂する

1つのページ(4KB)に格納できるレコード数には上限があります。上限を超えると、ページが **分割** されてツリーが成長します。

```
Step 1: リーフに4件入っている (上限=4)

  ┌───────────────────┐
  │ [1] [2] [3] [4]  │  ← 満杯
  └───────────────────┘

Step 2: 5件目 [5] を挿入 → 分割が発生

  ┌───────────────────┐        ┌───────────────────┐
  │ [1] [2] [3]      │  ───→  │ [4] [5]           │
  └───────────────────┘        └───────────────────┘
   左半分 (元のページ)           右半分 (新しいページ)

Step 3: 親の内部ノードが作られる

              ┌───────┐
              │  [4]  │  ← 新しいルート (内部ノード)
              └┬─────┬┘    「4未満は左、4以上は右」
               │     │
      ┌────────┘     └────────┐
      ▼                       ▼
  ┌──────────┐          ┌──────────┐
  │[1][2][3] │  ──────→ │ [4][5]   │
  └──────────┘          └──────────┘
```

**分割のポイント:**
- リーフが満杯になると「左半分/右半分」に分ける
- 右半分の最小キー（この例では `4`）が親に **昇格** する
- 親がまだ存在しない場合は、新しいルートノードが作られる
- 親も満杯になったら、親も分割される（再帰的に繰り返す）

### B+Tree の操作まとめ

| 操作 | やること |
|---|---|
| **INSERT** | ルートからリーフまで降りて、レコードをソート位置に挿入。満杯なら分割。 |
| **SEARCH** | ルートから内部ノードのキーを比較して子に降りる。リーフで目的のキーを探す。 |
| **SCAN** | 最左のリーフから右兄弟を辿って全レコードを順番に取得。 |

---

## 3-5 全体の連携図

SQL文の実行から実際のファイルI/Oまでの流れです。

```
 SQL文字列
 "INSERT INTO users (id, name) VALUES (3, 'Charlie');"
       │
       ▼
 ┌─────────────┐
 │ クエリー      │  parse() で Statement に変換
 │ エンジン      │  (1章・2章で解説)
 └──────┬──────┘
        │
        ▼  Statement オブジェクト
 ┌──────────────────────────────────────────────────────┐
 │                    Database                          │
 │                                                      │
 │  execute(stmt) でStatementの種類に応じた処理を実行      │
 │                                                      │
 │  ┌────────────────────────────────────────────┐      │
 │  │ INSERT の場合:                               │      │
 │  │  1. テーブル名でスキーマを検索                  │      │
 │  │  2. カラム検証・型変換・制約チェック             │      │
 │  │  3. B+Tree にレコードを挿入                   │      │
 │  └────────────────────┬───────────────────────┘      │
 │                       │                              │
 │  ┌────────────────────▼───────────────────────┐      │
 │  │              B+Tree                        │      │
 │  │                                            │      │
 │  │  insert({ key: 3, values: [3, "Charlie"] })│      │
 │  │                                            │      │
 │  │  1. ルートからリーフまで降りる                │      │
 │  │  2. リーフにレコードを挿入                   │      │
 │  │  3. 必要なら分割                            │      │
 │  │                                            │      │
 │  │  ページの読み書きは全て Pager 経由            │      │
 │  └────────────────────┬───────────────────────┘      │
 │                       │                              │
 └───────────────────────┼──────────────────────────────┘
                         │
    ┌────────────────────▼───────────────────────┐
    │              Pager                         │
    │                                            │
    │  readPage(2)  → ファイルから読む            │
    │  writePage(2, data) → ファイルに書く        │
    │  allocatePage() → 新ページ確保             │
    └────────────────────┬───────────────────────┘
                         │
                         ▼
                ┌─────────────────┐
                │   sqlight.db    │
                │                 │
                │ [Page0][Page1]  │
                │ [Page2][Page3]  │
                │   ...           │
                └─────────────────┘
```

### 各SQL操作で何が起きるか

**CREATE TABLE:**
```
1. Database: テーブル名の重複チェック
2. B+Tree:   空のリーフノード(1ページ)を作成 ← Pager.allocatePage()
3. Database: スキーマページに「テーブル名 + カラム定義 + ルートページ番号」を書き込み
             ← Pager.writePage(1, ...)
```

**INSERT INTO:**
```
1. Database: テーブル存在チェック、カラム検証、型変換、制約チェック
2. B+Tree:   ルートからリーフまで降りてレコードを挿入
             ← Pager.readPage() で各ノードを読む
             ← Pager.writePage() でリーフを更新
3. B+Tree:   リーフが満杯なら分割
             ← Pager.allocatePage() で新ページ確保
             ← Pager.writePage() で左右のリーフと親ノードを書く
4. Database: ルートページが変わった場合、スキーマページを更新
```

**SELECT:**
```
1. Database: テーブル存在チェック
2. B+Tree:   最左リーフから右兄弟を辿って全レコード取得 (scan)
             ← Pager.readPage() でリーフを順番に読む
3. Database: WHERE条件でフィルタリング
4. Database: 指定カラムだけに絞って結果を返す
```

### 本プロジェクトのファイル構成

```
src/
├── storage/
│   └── pager.ts      ← Pager: ページ単位のファイルI/O
├── db/
│   ├── btree.ts      ← B+Tree: ページ上で動作するツリー構造
│   └── database.ts   ← Database: クエリーエンジンとストレージエンジンの統合
└── main.ts           ← CLI: ユーザー入力 → parse → execute → 結果表示
```

各ファイルの実装詳細は → [4章: ストレージエンジンの実装詳細](./chapter4_storage_engine_impl.md)
